---
author: kapucode
pubDatetime: 2022-09-30T15:22:00Z
title: Next.jsとOpenAIで感情分析アプリを作る
postSlug: nextjs-openai-amotion-app
featured: true
draft: false
tags:
  - nextjs
  - openai
  - prisma
  - supabase
  - clerk
description:
  Next.js13とOpenAIで感情分析をしてくれるAIアプリの作り方を解説します。ユーザー認証機能を作り、ユーザーIDで感情分析データを管理します。データはPrismaを経由し、Supabaseに保存します。本書ではフルスタックアプリを作り上げます💪。所々Next.jsのコード進行のポイントを解説しています。Next.jsの入門書としてもお使い頂ける内容になっております😃
---

*補足:
・テキスト入力フォームにLexical(meta開発のリッチテキストエディタ)を使いますが本書の趣旨とは異なるのでLexicalの解説は深くしておりません。（要望があれば追記いたします）
・OpenAI APIキーの取得にはクレジット登録が必要です。(初めの3ヶ月は$18までAPIの利用が無料でできます)


## Table of contents

## はじめに
この本はNext.jsとOpenAIを使い、テキストエディタに文字を入力するとAIが入力データに基づいて感情分析をしてくれるアプリです。
感情分析結果をsupabaseに保存するところまでを実装します。

なお、AIのロジックを深く説明してるものではありません。Next.jsにどうやってAIを組み込むかと言うAIサービス開発の入門になります。読者様自身のアイデアの形にする手助けをするための本です。

### 使用技術
この本では以下の技術を取り扱います。
- Next.js(Typescript)
- Prisma(データモデル作成)
- supabase（データ置き場)
- clerk(ユーザー認証機能)

Next.jsではApp routerを使用します。

### 開発内容
開発内容は以下のとおりです。
- Prismaでデータモデルの作成方法
- Clerkでユーザー認証機能実装方法
- OpenAIAPIの使い方
- テキストデータの分析方法
- supabaseへデータの格納方法

### 事前準備
お使いのデバイスに以下をイストールしておいてください
- node
- npm(もしくはyarn)
- コードエディタ

### リポジトリ
完成のコードはこちらです。
https://github.com/ryotarofr/Emotional-analysis-apps
<br />
デモサイト
https://emotional-analysis-apps.vercel.app/

### 質問などお待ちしてます
ここがわかりにくいとか謎のエラーが出たとかありましたら質問していただければ随時対応していきますのでどんどん質問してくださいませ。




## Next.jsのプロジェクトを作成
今回はNext.jsの最新版を使うので以下のようなコマンドを入力してください。
```bash
npx create-next-app@latest ./
```
初期設定について聞かれますがデフォルトで大丈夫以下のように設定します
```
Ok to proceed? (y) y
✔ What is your project named? … ./
✔ Would you like to use TypeScript? … Yes
✔ Would you like to use ESLint? … Yes
✔ Would you like to use Tailwind CSS? … Yes
✔ Would you like to use `src/` directory? … Yes
✔ Would you like to use App Router? (recommended) … Yes
✔ Would you like to customize the default import alias? … No
...
Success!
```
Success!と表示されれば完了です。

初期設定が終わったらブラウザでを立ち上げます。
以下のコマンドを入力してhttp://localhost:3000/を立ち上げてください
```
npm run dev
```

![](https://storage.googleapis.com/zenn-user-upload/8bbdd0ee5c05-20230927.png)
このような画面が表示されればセットアップ完了です。
これで最初の準備は整いました。うまく動かない場合は環境設定がうまくいっていない可能性がありますので、エラーメッセージなどを確認してみてください。


このセクションは飛ばして読み進めることも可能です。ユーザー認証いらないよって方は以降のセクションへ。
clerkを使えばとても簡単にユーザー認証機能を実装することができます。
[clerk公式サイト](https://clerk.com/docs)


<br />
<br />

### clerkのアプリ設定
公式のダッシュボードにログインしてください。
Add applicationを押すと以下のような画面に遷移します。
アプリケーションネームを使う認証プロバイダの設定をしてcreate applicationを押します。
今回はEmail addresとGoogleプロバイダを使います。
![](https://storage.googleapis.com/zenn-user-upload/596b563cdf8e-20230927.png)


ルートディレクトリに.env.localを作成しAPIキーを貼り付けます。
![](https://storage.googleapis.com/zenn-user-upload/5e675fa6dc82-20230927.png)


### clerkのインストール
ターミナルに以下のコマンドを打ち込みます
```
npm i @clerk/nextjs
```



## clerkで認証機能を実装
あまり本質的な部分ではありませんのでふーんって思ってもらえれば大丈夫です。コピペで構いません。
まずは、アプリ全体にユーザー認証を適応させます。
ClerkProviderでタグをラップします。
app/layout.tsx
```js
import { ClerkProvider } from '@clerk/nextjs'
...
...
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <ClerkProvider> //追加
      <html lang="en">
        <body className={inter.className}>{children}</body>
      </html>
    </ClerkProvider>　 //追加
  )
}

```

### 認証ディレクトリの作成
プロジェクトに認証ページを作成していきます。
src/appフォルダの中に次のフォルダとファイルを作成してください
![](https://storage.googleapis.com/zenn-user-upload/c4fd8bac720a-20230927.png)

Next.js13のApp routerではlayout.tsxやloading.tsx時まったページ名が用意されています。
layout.tsxは共通するスタイルやコンポーネントを管理できます。
(auth)のディレクトリを作ることで(auth)ページだけのlayout.tsxを作ることができます。
(auth)/layout.tsxとすることでユーザー認証画面の共通プロパティを親のapp/layout.tsxを分けて決めることができ流のでより柔軟に開発ができます。

app/(auth)/layout.tsx
```js
const AuthLayout = ({
  children
}: {
  children: React.ReactNode;
}) => {
  return (
    <main className="min-h-screen flex items-center justify-center">
      {children}
    </main>
  );
}

export default AuthLayout;
```

コンポーネントを管理するフォルダを作ります。
以下のフォルダとファイルを作ってください
**app/components/ui**
今回はuiというフォルダでボタンなどのuiを管理します。
エラーが発生した場合にエラーメッセージを表示するuiを追加します。
empty.pngは添付したgithubのpublicフォルダにあものを使ってください。

components/ui/empty.tsx
```js
import Image from "next/image";


interface EmptyProps {
  label: string;
}

export const Empty = ({
  label
}: EmptyProps) => {
  return (
    <div className="h-full p-20 flex flex-col items-center justify-center">
      <div className="relative h-72 w-72">
        <Image src="/empty.png" fill alt="Empty" />
      </div>
      <p className="text-muted-foreground text-sm text-center">
        {label}
      </p>
    </div>
  );
};
```

エラーページを作ります。
:::message
ポイント
empty.tsxにpropsを持たせています
label="Something went wrong."
このようにすることでエラーのメッセージ内容ををページごとに変更することができます
:::
"use client"と表記するのはNext.js13のapp routerでは**デフォルトでサーバーサイドコンポーネント**になっているので「**クライアントサイドのコードですよ**」とNext.jsに教えてあげるためです。
　エラーはクライアントサイドで表示させるのでこのような記述が必要になるわけです。
app/(auth)/error.tsx
```js
"use client"
import { Empty } from "../components/ui/empty";

const Error = () => {
  return (
    <Empty label="Something went wrong." />
  );
}

export default Error;

```

サインイン・サインアップのページを追加します。
これも簡単なコードです。
(auth)/sign-in/[[...sign-in]]/page.tsx
```js
import { SignIn } from "@clerk/nextjs";

export default function Page() {
  return <SignIn />;
}
```

(auth)/sign-up/[[...sign-up]]/page.tsx
```js
import { SignUp } from "@clerk/nextjs";

export default function Page() {
  return <SignUp />;
};
```

コードが書けたら　http://localhost:3000/　が以下のような表示になります。

![](https://storage.googleapis.com/zenn-user-upload/8f4ccd7a99c2-20230927.png)

しかし、ページに入ったらすぐにログインしっててのはアプリとしては変ですよね。
そこで、publicRoutesというログインしてなくてもみれますよって記述をしていきます。
以下のファイルを作りコードを書きます。
src/middleware.ts
```js
import { authMiddleware } from "@clerk/nextjs";

export default authMiddleware({
  publicRoutes: ["/"],
});
```
これで http://localhost:3000/ のページで認証ページに遷移しないようになります。

ターミナルを見ると
```bash
Clerk: The middleware was skipped for this request URL: http://localhost:3000/_next/static/chunks/app/page.js. For performance reasons, it's recommended to your middleware matcher to:
export const config = {
  matcher: ["/((?!.+\\.[\\w]+$|_next).*)","/","/(api|trpc)(.*)"],
};
```

このような表記されているのでミドルウェアに追記します。
これはNext.jsのファイルルーティングをいい感じにしてくれるおまじないだという認識で大丈夫です。
src/middleware.ts
```js
import { authMiddleware } from "@clerk/nextjs";

export default authMiddleware({
  publicRoutes: ["/"],
});

//追加
export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

そして、サインイン・サインアップが完了したらどこのページに遷移するかも決めることができます。
.env.localに以下の記述をしてください
今回は/noteというページに遷移することにします。
.env.local

```
//追加
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/note
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/note
```

### コンポーネントを作成
Navbarに認証ボタンを入れていきます。
components/Navbar/landing-navbar.tsx
というファイルを作ります。
そこにclerkからセッションを呼び出します。
/landing-navbar.tsx
```js
"use client";
import Link from "next/link"
import { useAuth } from "@clerk/nextjs";

export const LandingNavbar = () => {
  const { isSignedIn } = useAuth();

  return (
    <nav>
        <Link
          href={isSignedIn ? "/note" : "/sign-up"}
        >
          ログイン
        </Link>
    </nav>
  )
}

```

Tailwindcssで少しスタイルを当てます。
/landing-navbar.tsx
```js
"use client";

import Image from "next/image"
import Link from "next/link"
import { useAuth } from "@clerk/nextjs";

export const LandingNavbar = () => {
  const { isSignedIn } = useAuth();

  return (
    <nav
      className="mx-4 py-8 bg-transparent flex items-center justify-between
      md:mx-20
    ">
      <div className="flex items-center gap-x-2">
        <Link
          href={isSignedIn ? "/note" : "/sign-up"}
          className="no-underline text-white bg-indigo-900 px-4 py-2 rounded-full hover:bg-indigo-800"
        >
          ログイン
        </Link>
      </div>
    </nav>
  )
}
```

作ったコンポーネントを表示させます
src/app/page.tsx
```js
//...
import { LandingNavbar } from './components/Navbar/landing-navbar'

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <LandingNavbar /> //追加
     // ...省略
    </main>
  )
}

```

ログインボタンが表示されているかローカルホストを立ち上げて確認してみましょう。
実際にログインしてみると/noteにページ遷移します。
![](https://storage.googleapis.com/zenn-user-upload/c64d3984e42e-20230928.png)


これで認証機能は出来上がりです。

<br />
<br />
Noteページではテキストフォームを作ります。

### ディレクトリを作成
以下のようなディレクトリを作成します。
app/(site)/layout.tsx
app/(site)/(routes)/note/page.tsx
(auth)の時と同じようにディレクトリを作りましす。
(site)という名前にしましたが、なんでもいいです。
(routes)フォルダは個人的にディレクトリが2つ以上になる場合はあったほうがいいかなと思います。
![](https://storage.googleapis.com/zenn-user-upload/c5a447251b8b-20230928.png)

ページの編集をしていきます。
(site)/layout.tsx
```js
const SiteLayout = ({
  children,
}: {
  children: React.ReactNode
}) => {

  return (
    <div>
      {children}
    </div>
  )
}

export default SiteLayout
```

(site)/(routes)/note/page.tsx
```js
const NotePage = () => {
return(<>
	<div>note</div>
</>)
}
```

見栄えが悪いのでglobal.cssを修正します。
app/global.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* コメントアウト */
/* :root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
} */

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}
```

<br />
<br />

チャートページでは、感情分析の結果をグラフに描画していきます。

### ディレクトリを作成
noteと同じようにディレクトリを作成します。
app/(site)/(routes)/chart/page.tsx

ページの編集をしていきます。
(site)/(routes)/chart/page.tsx
```js
const ChartPage = () => {

  return (
    <>
      <div>チャートページ</div>
    </>
  )
}

export default ChartPage
```

### ページ遷移用の(site)にナビゲーションバーを作る
先にアイコンを使うのでパッケージをインストールします。
ターミナル
```bash
npm i react-icons
```
先ほど作ったcomponents/Navbarに　**site-navbar.tsx**　のファイルを追加します。
それではコードを書いていきます。
components/Navbarsite-navbar.tsx
```js
"use client";

import { usePathname } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import { UserButton } from "@clerk/nextjs";
import { AiOutlineBarChart } from "react-icons/ai"
import { GiNotebook } from "react-icons/gi"

const navItems = [
  {
    path: "/note",
    name: "Note",
    icon: <GiNotebook size={24} />
  },
  {
    path: "/chart",
    name: "Chart",
    icon: <AiOutlineBarChart size={24} />
  },
];

export default function NavBar() {
  let pathname = usePathname() || "/";

  return (
    <div className=" p-[0.4rem] rounded-lg mb-12 sticky top-4 z-[100]">
      <div className="flex gap-2 relative justify-around items-center w-full z-[100]  rounded-lg">
        <div className="hidden sm:block">
          <Link href="/" className="flex items-center no-underline text-zinc-900">
            <Image width={36} height={36} alt="Logo" src="/logo.png" />
            <span className="text-2xl">
              My-App
            </span>
          </Link>
        </div>
        <div className="flex">
          {navItems.map((item, index) => {
            const isActive = item.path === pathname;

            return (
              <Link
                key={item.path}
                className={`px-4 py-2 rounded-md text-sm lg:text-base hover:bg-slate-200 relative no-underline duration-300 ease-in ${isActive ? "text-zinc-400" : "text-zinc-900"
                  }`}
                href={item.path}
              >
                <div className="flex items-center">
                  <div className="">{item.icon}</div>
                  <div className="hidden sm:block">{item.name}</div>

                </div>
              </Link>
            );
          })}
        </div>

        <UserButton afterSignOutUrl="/" />

      </div>
    </div>
  );
}
```

#### コードの解説
**usePathname**は**クライアントサイド**のhooksです。なので"use client"をつける必要があります。
usePathnameは文字列を返しますが、以下の場合にnullを返します。
- フォールバックルートがレンダリングされているとき
- Next.jsが自動的に静的最適化したページが表示されているとき
- ルーターが準備できていないとき
このような場合に、nullを返すのではなく、デフォルトのパス名を設定したいときに、||という演算子を使います。||は、論理和（OR）と呼ばれる演算子で、左側の値が真（truthy）であればその値を返し、偽（falsy）であれば右側の値を返します。nullは偽とみなされるので、usePathname()がnullを返したら、右側の"/"が代わりに返されます。
```js
let pathname = usePathname() || "/";
```

navItemsという配列をmapメソッドで反復処理して、各要素に対してLinkコンポーネントを返すものです。LinkコンポーネントはNext.jsのルーティング機能を利用して、ページ間の遷移を行うものです。
item.pathと現在のパス名（pathname）が一致するかどうかをisActiveという変数に代入しています。これは、現在アクティブなナビゲーションアイテムを判別するために使われます。
```js
...
{navItems.map((item) => {
            const isActive = item.path === pathname;

            return (
              <Link
                key={item.path}
                className={`px-4 py-2 rounded-md text-sm lg:text-base hover:bg-slate-200 relative no-underline duration-300 ease-in ${isActive ? "text-zinc-400" : "text-zinc-900"
                  }`}
                href={item.path}
              >
                <div className="flex items-center">
                  <div className="">{item.icon}</div>
                  <div className="hidden sm:block">{item.name}</div>

                </div>
              </Link>
            );
          })}
...
```

#### ナビゲーションバーを表示させる
ナビゲーションバーは共通のコンポーネントなので(site)/layout.tsxに追加していきます。
(site)/layout.tsx
```js
import NavBar from "../components/Navbar/site-navbar"

const SiteLayout = ({
  children,
}: {
  children: React.ReactNode
}) => {

  return (
    <div>
      <NavBar />
      {children}
    </div>
  )
}

export default SiteLayout
```
以下のように表示れています。
ボタンを押すとページの遷移ができるようになっています。
![](https://storage.googleapis.com/zenn-user-upload/b9bed3b2db21-20230928.png)


<br />
<br />

今回Lexicalについて深く解説しません。
お手数ですが、app/componentsにgithubのコードをコピペしてお使いくださいm(_ _)m
[Lexicalエディタ](https://github.com/ryotarofr/lexacal-example)
↓ここにコピペ
app/components/Editor/... 
![](https://storage.googleapis.com/zenn-user-upload/eb7acaf386ee-20230928.png)


### パッケージのインストール
まずは以下のパッケージをインストールしてください
ターミナル
lexicalのバージョンは0.11.0を使います。
リッチエディタツール
```bash
npm install @lexical/list@0.11.0 @lexical/react@0.11.0 lexical@0.11.0
```
処理結果の通知を画面に表示するモジュール
```bash
npm i react-hot-toast
```


### ノートページにテキストエディタを表示させる
エディタコンポーネントを表示させます。以下のコードを追加してください
(site)/(routes)/note/page.tsx
```js
import { Editor } from "@/app/components/Editor/text-editor"

const NotePage = () => {

  return (
    <div>
      <Editor />
    </div>
  )
}

export default NotePage
```


#### テキストエディタのスタイルを追加
こちらもコピペでお使いください
[テキストエディタのスタイル](https://github.com/ryotarofr/lexacal-example/blob/main/styles.css)
以下の場所にファイルを追加
(site)/styles.css
![](https://storage.googleapis.com/zenn-user-upload/e0c42e199f9d-20230928.png)

最後にlayout.tsxにスタイルを適応させます。
(site)/layout.tsx
```js
import "./styles.css"
```

#### ローカルホストを立ち上げて確認してみましょう。
/noteのページにテキストエディタが表示されていればOKです。
![](https://storage.googleapis.com/zenn-user-upload/50041e402505-20230928.png)

ちなみにですが、レスポンシブ対応もバッチリです。
![](https://storage.googleapis.com/zenn-user-upload/606429b4510e-20230928.png)

<br />
<br />

OpenAIのAPIを使って感情分析をするコードを書いていきます。
はじめにOpenAIのAPIキーを取得します。(APIキーの取得にはクレジット登録が必要です。最初の3ヶ月は$18まで無料です。）
以下のドキュメントページから
View API Keys >> Create new secret key
でAPIキーを発行できます。
[OpenAI ドキュメント](https://platform.openai.com/docs/introduction)
![](https://storage.googleapis.com/zenn-user-upload/817d9fce5cb7-20230928.png)


それでは、text-editor.tsxにコードを追加します。
```js
//...
export function Editor() {
//追加
    const [generateData, setGenarateData] = useState("{}")
//追加
    // AIにデータ渡す
    // JSONとして解析
    const parsedData = JSON.parse(generateData);
    // 必要なデータを抽出
    const textObjects: any = [];
    function extractText(obj: any) {
        // objがnullや空のオブジェクトならreturnする
        if (!obj || Object.keys(obj).length === 0) return;
        if (obj.type === 'text') {
            textObjects.push(obj.text);
        } else if (obj.children && obj.children.length > 0) {
            obj.children.forEach((child: any) => extractText(child));
        }
    }
    // parsedData.rootがundefinedでないことを確認する
    if (parsedData.root) {
        extractText(parsedData.root);
    }
    const textData = textObjects.join(',')
    
//追加
    const exportAsJson = (contenAsJson: string) => {
        setGenarateData(contenAsJson)
        return contenAsJson
    };
//...
    return (
        <LexicalComposer initialConfig={editorConfig}>
            <div className="editor-container">
                <ToolbarPlugin />
                <div className="editor-inner">
                    <RichTextPlugin
                        contentEditable={<ContentEditable className="editor-input" />}
                        placeholder={<Placeholder />}
                        ErrorBoundary={LexicalErrorBoundary}
                    />
                    <ListPlugin />
                    <HistoryPlugin />
                    <AutoFocusPlugin />
                    <CodeHighlightPlugin />
                    <LinkPlugin />
                    <TabIndentationPlugin />
                    <AutoLinkPlugin />
		{/* 追加 */}		
                    <ExportPluginJson exportAsJSON={exportAsJson} />
                
		<MarkdownShortcutPlugin transformers={TRANSFORMERS} />
		{/* 追加 GenarateButtonは下のセクションで作ります。 */}
                    <div className="flex justify-end">
                        <GenarateButton textData={textData} />
                    </div>
                </div>
		{/* ... */}
            </div>
        </LexicalComposer>
    );
}

```

#### コードの解説
Lexicalで入力したテキストデータをstateに持たせます。
```js
 const [generateData, setGenarateData] = useState("{}")
 ```
 
 stateはjson形式で出力するのでLexicalのプラグインを使います。
 ```js
 <ExportPluginJson exportAsJSON={exportAsJson} />
 ```
  exportAsJsonという関数には先ほど定義したsetGenarateDataにデータを渡すようにします。
  
  :::details 具体的にはこんな感じのデータが渡されます。
  これは「こんにちは」というデータです。
{"root":{"children":[{"children":[{"detail":0,"format":0,"mode":"normal","style":"","text":"こんにちは","type":"text","version":1}],"direction":"ltr","format":"","indent":0,"type":"paragraph","version":1}],"direction":"ltr","format":"","indent":0,"type":"root","version":1}}
:::
 ```js
  const exportAsJson = (contenAsJson: string) => {
        setGenarateData(contenAsJson)
        return contenAsJson
    };
 ```
 
 次に先ほどのJsonデータからテキストデータを抜き出します。
 先ほどの例で行くと「こんにちは」を抜き出していきます。

JSON.parse()できるデータには以下の条件があります。
 :::details JSON.parse()できるデータには条件があります。
 1　キー：値はダブルクォーテーションで囲む
```js
'{"name": "John"}' // 正しい
'{"name": 'John'}' // エラー - シングルクォーテーションは認識されない
```
 2 数値はダブルクォーテーションなし
 ```js
 '{"age": 30}' // 正しい
'{"age": "30"}' // エラー - ダブルクォーテーションで囲まれた数値は文字列として扱われる
```

3 特殊文字を適切にエスケープ(バックスラッシュとダブルクォーテーションはそのまま使えないので\　\を前につけます。)
```js
'{"text": "This is a \\"quoted\\" string."}' // エスケープされたダブルクォーテーション
'{"path": "C:\\\\Documents\\\\file.txt"}' // バックスラッシュのエスケープ
```
 :::
 
 このようにするとtextDataに「こんにちは」というデータを抽出できます。。
 ```js
    // AIにデータ渡す
    // JSONとして解析
    const parsedData = JSON.parse(generateData);
    // 必要なデータを抽出
    const textObjects: any = [];

    function extractText(obj: any) {
        // objがnullや空のオブジェクトならreturnする
        if (!obj || Object.keys(obj).length === 0) return;
        if (obj.type === 'text') {
            textObjects.push(obj.text);
        } else if (obj.children && obj.children.length > 0) {
            obj.children.forEach((child: any) => extractText(child));
        }
    }
    // parsedData.rootがundefinedでないことを確認する
    if (parsedData.root) {
        extractText(parsedData.root);
    }
    const textData = textObjects.join(',')
 ```
 
 最後にtextDataをGenarateButtonにpropsにます。
 ```js
 <div className="flex justify-end">
	<GenarateButton textData={textData} />
</div>
 ```
 
 
 #### GenarateButtonを作ります
 以下のファイルを作ってください。
 app/components/GenarateButton/index.tsx
 このファイルではOpenAIのAPIを使って入力テキストから感情の属性を出力させます。
 :::details 感情の種類
negative: ネガティブ
  positive: ポジティブ
  neutral: どちらでもない
  joy: 楽しい
  trust:　信頼
  fear:　恐れ
  surprise:　驚き
  sadness:　悲しみ
  disgust:　険悪
  anger:　怒り
  anticipation:　期待
:::
 コードを書いていきます。
  app/components/GenarateButton/index.tsx
 ```js
 "use client"

import { useState } from "react";

export function GenarateButton({
  textData,
}: {
  textData: string
}) {
  const [isLoading, setIsLoading] = useState(false);
  const [generateData, setGenerateData] = useState<string[]>([]);

  const handleSubmit = async (e: { preventDefault: () => void }) => {
    e.preventDefault();
    if (textData === "") return;
    setIsLoading(true);
    // const API_KEY = process.env.OPENAI_API_KEY
    const API_KEY = "OpenAI API Keyを追加"
    const model = "text-davinci-003";
    const URL = "https://api.openai.com/v1/engines/" + model + "/completions";

    const questions = `前提条件：あなたは、世界でも有数の精神分析家です。
    文章から、著者の心理状態を分析することに長けています。
    次の文章をもとに心理分析してください。
    文章の返答形式はそれぞれの感情属性に1~10までの点数で評価してください。
    {EmotionalAnalysis:[
      {"negative":""},
      {"positive":""},
      {"neutral":""},
      {"joy":""},
      {"trust":""},
      {"fear":""},
      {"surprise":""},
      {"sadness":""},
      {"disgust":""},
      {"anger":""},
      {"anticipation":""}
    ]}
    の形式で精神分析をします。

    文章：${textData}
    `
    const res = await fetch(URL, {
      method: "POST",
      body: JSON.stringify({
        prompt: questions,
        max_tokens: 200,
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${API_KEY}`,
      },
    });

    const json = await res.json();

    const filterData = json.choices ? json.choices.map((value: { text: string }) => {
      const str = `{"EmotionalAnalysis":`
      const i = value.text.indexOf(str);
      return value.text.substring(i);
    }) : [];

    setGenerateData(filterData);
    setIsLoading(false);

  };

  return (
    <>
        <button
          onClick={handleSubmit}
          className="mx-4 mb-2 mt-2 text-md cursor-pointer rounded-lg border-none px-4 py-2 bg-lime-600 hover:bg-lime-700 text-white"
        >
          Generate
        </button>
        <p>{isLoading ? "loading" : null}</p>
	{/* とりあえず表示 */}
        <div className="text-2xl">{generateData}</div>
    </ >

  )
}
 ```
 
 #### コードを解説
 ボタンをクリックするとhandleSubmit関数が実行されます。
 handleSubmitの中で感情分析を実装します。
 textDataが空の場合は何も実行しません。
 ```js
 if (textData === "") return;
 ```
 
 handleSubmit関数にasyncとしているようにテキストの分析は非同期で行うので
 分析が終わるまではローディングを表示させます。
 ```js
 setIsLoading(true);
 ```
 
 以下のコードでapiを使うことができます。
 本来APIキーなどの他人に見せたくないものは.envファイルに記述しますが、
 const API_KEY = process.env.OPENAI_API_KEYこのように記述するとAPIキーを呼び出せないので今回は直に書いています。(修正方法探します)
 今回は、text-davinci-003というモデルを使います。text-davinci-003はテキストジェネレイトに優れたモデルです。
 questionsに条件を記入してそれをPostメソッドのbodyに入力しています。
 文章には代入演算子てtextDataを入れています。
 textDataは先ほどJson文字列からテキストを抜き出したデータです。
 APIから帰ってきたデータをjsonという定数に代入しています。
 ```js
 const API_KEY = "OpenAI API Keyを追加"
    const model = "text-davinci-003";
    const URL = "https://api.openai.com/v1/engines/" + model + "/completions";

    const questions = `前提条件：あなたは、世界でも有数の精神分析家です。
    文章から、著者の心理状態を分析することに長けています。
    次の文章をもとに心理分析してください。
    *文章の返答形式はそれぞれの感情属性に1~10までの点数で評価してください。
    {EmotionalAnalysis:[
      {"negative":""},
      {"positive":""},
      {"neutral":""},
      {"joy":""},
      {"trust":""},
      {"fear":""},
      {"surprise":""},
      {"sadness":""},
      {"disgust":""},
      {"anger":""},
      {"anticipation":""}
    ]}
    の形式で精神分析をします。

    文章：${textData}
    `
    const res = await fetch(URL, {
      method: "POST",
      body: JSON.stringify({
        prompt: questions,
        max_tokens: 200,
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${API_KEY}`,
      },
    });

    const json = await res.json();
 ```
 
 jsonには不要な文章も含まれるので必要な部分をフィルタリングします。
:::details こんなデータが帰ってきます
入力: こんにちは、私は朝バナナを食べました。おいしかったです！！
出力: この文章をもとに心理分析をします。文章の著者は、朝バナナを食べたことに対して非常に喜びを感じています。また、バナナがおいしかったということから、味覚に対する感受性が高いと推測できます。さらに、文章の語尾に感嘆符を二つ使っていることから、感情表現が豊かで、自分の気持ちを素直に伝えるタイプであると考えられます。文章から読み取れる感情属性の点数は以下のようになります。

{EmotionalAnalysis:[
  {"negative":"0"},
  {"positive":"10"},
  {"neutral":"0"},
  {"joy":"10"},
  {"trust":"0"},
  {"fear":"0"},
  {"surprise":"0"},
  {"sadness":"0"},
  {"disgust":"0"},
  {"anger":"0"},
  {"anticipation":"0"}
]}

以上が心理分析の結果です。文章の著者は、朝バナナを食べることで幸せな気持ちになっているようですね😊
:::
具体的にほしいデータ{"EmotionalAnalysis":...}
を抽出します。
```js
const filterData = json.choices ? json.choices.map((value: { text: string }) => {
      const str = `{"EmotionalAnalysis":`
      const i = value.text.indexOf(str);
      return value.text.substring(i);
    }) : [];
```

最後にfilterDataを色々使い回すためにsetGenerateDataのstateに代入します。
handleSubmitの処理が終わったのでローディングをfalseにします。
```js
setGenerateData(filterData);
setIsLoading(false);
```

とりあえずstateの値を表示させています。
私の画面では以下のような出力結果になっています。
```js
{/* とりあえず表示 */}
<div className="text-2xl">{generateData}</div>
```

![](https://storage.googleapis.com/zenn-user-upload/79496df6dec5-20230928.png)

これでデータのジェネレイトは完了です。
次はPrismaでデータを保存するロジックを作ります。

<br />
<br />

Prismaのセットアップ
prismaをインストールします。
```bash
npm install prisma --save-dev
npm install @prisma/client
```
```bash
npx prisma init
```

.envに以下のコードが生成されます。
```
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"
```

.env.localを.envにコピペします。(以降.env.localは使わないので削除します。)
```
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_Y2hpZWYtYnVjay03OS5jbGVyay5hY2NvdW50cy5kZXYk
CLERK_SECRET_KEY=sk_test_eWY4OXh0aUqAYf2zrTM9ifFFyTpI5Np0nH6Ojb0B10

NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/note
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/note

DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"
```

#### Supabaseセットアップ
データベースにSupabaseを使うのでセットアップをしていきます。
アカウントがない場合は作成してください
[supabase サインイン](https://app.supabase.com/sign-in)


ダッシュボードへ移動して
https://supabase.com/dashboard/projects
「New Project ボタン」を押してプロジェクトを作成します。
Nameは任意、RegionはTokyo、Pricingは Freeに設定して作成しましょう。
Freeでは500MBまで DBが使えます
![](https://storage.googleapis.com/zenn-user-upload/d3d974b2ded3-20230928.png)


次にサイドバーの 「setting」 > 「Database」> Connection string > url の文字列をコピー。
これがprismaがsupabaseに接続するための情報です。
![](https://storage.googleapis.com/zenn-user-upload/5252efa159bc-20230928.png)

urlを.envのDATABASE_URLに置き換えます。
[パスワード]の部分を設定したものを入力します。
**test123**の場合は次のようになります。
```
//...
DATABASE_URL=postgresql://postgres:test123@db.idwitrlwanewneoypjki.supabase.co:5432/postgres
```

#### Prismaのスキーマを作成
自動生成されたprisma/schema.prismaファイルに新しいモデルを作ります。
:::details modelについて
modelには主キーが必要です。今回はidを主キーにし、autoincrementで順番に番号を割り当てます。
testとuserIdは?をつけnullを許容しています。
created_atは@default(now())で今の時間を自動で割り当てます。
emotionには感情分析の結果が入るので[]として配列データを渡しています。
:::
prisma/schema.prisma
```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
//追加
model Analysis {
  id         Int      @id @default(autoincrement())
  text       String?
  created_at DateTime @default(now())
  userId     String?
  emotion    String[]
}

```

ここまで来れば 「migrate dev」でマイグレーションファイルの作成し、supabaseに反映されます。
「--name」に指定した名前でマイグレーションが作成されます。次にgenerateで型情報を作成します。
```bash
npx prisma migrate dev --name init
npx prisma generate
```

デプロイ時にgenerateををする必要があるので
package.jsonに追加します。
```json
{
//...
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate" //追加
  },
  //...
}
```
<br />
<br />

### Prismaのデータベースにアクセス
Next.jsのapiルートでPrismaを使うためにまずはPrismaのデータベースにアクセスします。
app/libs/prismadb.tsを作ります。
libsフォルダは外部のライブラリやモジュールに依存するロジックを追加する時に使います。
データベースやAPIにアクセスする関数、認証や認可を行う関数などはここに収めていきます。

app/libs/prismadb.ts
```js
import { PrismaClient } from "@prisma/client"

declare global {
  var prisma: PrismaClient | undefined
}

const prismadb = globalThis.prisma || new PrismaClient()
if (process.env.NODE_ENV !== "production") globalThis.prisma = prismadb

export default prismadb;

```

#### コードの解説
グローバル変数として prisma という名前の Prisma Client のインスタンスを宣言するためのものです。PrismaClient | undefined という型は、prisma が Prisma Client のインスタンスか、未定義かを表します。
```js
declare global {
  var prisma: PrismaClient | undefined
}
```

開発環境であれば、グローバル変数 prisma に prismadb の値を代入します。これは、開発環境でホットリロードが発生したときに、Prisma Client のインスタンスが複数作られないようにするためのものです。
```js
if (process.env.NODE_ENV !== "production") globalThis.prisma = prismadb
```

###  API作成
#### 全てのデータを取得
apiを作るためにディレクトリ追加
app/api/analysis/route.ts

データの取得にはGetという関数を使います。
```js
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs";
import prismadb from "@/app/libs/prismadb";

export const GET = async (req: Request, res: NextResponse) => {
  try {
    const { userId } = auth();
    const getAllText = await prismadb.analysis.findMany({
      where: {
        userId: userId
      }
    });
    return NextResponse.json({ message: "Success", getAllText }, { status: 200 });
  } catch (err) {
    return NextResponse.json({ message: "Error", err }, { status: 500 });
  } finally {
    await prismadb.$disconnect();
  }
};
```

##### コードの解説
apiの関数は基本的に非同期処理のため関数にasyncをつけます。
try-catch-finally文を使うとエラーの出力がわかりやすいです。
tryの中ではまず、ユーザーIDを紐づけるためにclerkから呼び出しています。
そして、データベースからユーザーIDに紐づいたデータを全て呼び出すのでprismaのfindMany関数を使います。
:::details 今回使ったprisma関数一覧
findMany: whereで指定した全てのデータを呼び出す
findFirst: whereで指定した初めのデータを呼び出す
create: bodyデータを作成
update: bodyデータの更新
delete: bodyデータの削除
:::
```js
const { userId } = auth();
    const getAllText = await prismadb.analysis.findMany({
      where: {
        userId: userId
      }
    });
```

#### データの作成
次はデータの作成をするapiを作ります。
app/api/analysis/route.ts
```js
export const POST = async (req: Request, res: NextResponse) => {
  try {
    const { userId } = auth();

    const { text } = await req.json();

    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }
    const createText = await prismadb.analysis.create({ data: { text, userId } });
    return NextResponse.json({ message: "Success", createText }, { status: 201 });
  } catch (err) {
    return NextResponse.json({ message: "Error", err }, { status: 500 });
  } finally {
    await prismadb.$disconnect();
  }
};

```

##### コードの解説
userがログインしてない場合にエラーを出すようにしています。
```js
if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }
```
analysisのレコードにtext, userIdを渡します。textはフロントエンドからの入力データをリクエストします。
```js
   const createText = await prismadb.analysis.create({ data: { text, userId } });
```

#### 特定のデータのAPIを作成
##### ディレクトリを追加
指定したidのデータのapiを作ります。以下のようなファイルを作ります。
api/analysis/[id]/route.ts

##### 指定したidのデータを取得
api/analysis/[id]/route.ts
```js
import { NextResponse } from "next/server";
import prismadb from "@/app/libs/prismadb";

export const GET = async (req: Request, res: NextResponse) => {
  try {
    const id: number = parseInt(req.url.split("/analysis/")[1]);

    const getAnalysisById = await prismadb.analysis.findFirst({
      where: {
        id,
      }
    });

    if (!id) {
      return NextResponse.json({ message: "Not Found" }, { status: 404 });
    }

    return NextResponse.json({ message: "Success", getAnalysisById }, { status: 200 });
  } catch (err) {
    return NextResponse.json({ message: "Error", err }, { status: 500 });
  } finally {
    await prismadb.$disconnect();
  }
};
```

#### コードの解説
apiのリクエストを送る際、データのidが1のものを取得する場合
**http://localhost:3000/api/analysis/1**
このようにリクエストを送ります。
その部分のidの番号だけがほしいのでurlパラメータをsplitしてidを抜き出します。
```js
const id: number = parseInt(req.url.split("/analysis/")[1]);
```

findFirstは一番初めのデータを取得します。(findUniqueでも可)
```js
const getAnalysisById = await prismadb.analysis.findFirst({
      where: {
        id,
      }
    });
```

idがない時はエラーを返します。
```js
if (!id) {
      return NextResponse.json({ message: "Not Found" }, { status: 404 });
    }
```

##### 指定したidのデータを更新
指定したidのデータの更新をします。
```js
export const PUT = async (req: Request, res: NextResponse) => {
  try {
    const id: number = parseInt(req.url.split("/analysis/")[1]);
    const { text } = await req.json();

    const putAnalysis = await prismadb.analysis.update({
      data: { text },
      where: {
        id,
      },
    });

    return NextResponse.json({ message: "Success", putAnalysis }, { status: 200 });
  } catch (err) {
    return NextResponse.json({ message: "Error", err }, { status: 500 });
  } finally {
    await prismadb.$disconnect();
  }
};
```
#### コードの解説
Postとほとんど同じですが
data: { text } このようにdataにリクエストデータを渡します。
```js
const putAnalysis = await prismadb.analysis.update({
      data: { text },
      where: {
        id,
      },
    });
```

#### 指定したIdの削除
prismadb.analysis.deleteとすることでデータを削除できます。
```js
export const DELETE = async (req: Request, res: NextResponse) => {
  try {
    const id: number = parseInt(req.url.split("/analysis/")[1]);

    const deleteAnalysis = await prismadb.analysis.delete({
      where: { id },
    });

    return NextResponse.json({ message: "Success", deleteAnalysis }, { status: 200 });
  } catch (err) {
    return NextResponse.json({ message: "Error", err }, { status: 500 });
  } finally {
    await prismadb.$disconnect();
  }
};

```

#### 指定したIdの感情分析結果の更新
感情分析の結果もテキストの更新があった際に、更新できるようにします。
##### ディレクトリの追加
openai/[id]/route.ts

先ほどと違うのはリクエストデータにemotionを指定しているだけです。
こうすることでemotionのデータを更新できます。
```js
import { NextResponse } from "next/server";
import prismadb from "@/app/libs/prismadb";
import { auth } from "@clerk/nextjs";


export const PUT = async (req: Request, res: NextResponse) => {
  try {
    const { userId } = auth();
    const id: number = parseInt(req.url.split("/openai/")[1]);
    const { emotion } = await req.json();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const putEmotion = await prismadb.analysis.update({
      data: { emotion },
      where: {
        id,
      },
    });

    return NextResponse.json({ message: "Success", putEmotion }, { status: 200 });
  } catch (err) {
    return NextResponse.json({ message: "Error", err }, { status: 500 });
  } finally {
    await prismadb.$disconnect();
  }
};
```

これでapiの作成は完了しました。

<br />
<br />


## 投稿ボタン作成
##### apiデータをフェッチするためのパッケージをインストール
```bash
nom i axios
```
##### 状態管理パッケージをインストール
```bash
npm i zustand
```


##### コンポーネント作成
ボタンコンポーネント
app/components/PostButton/index.tsx
apiフェッチコンポーネント
app/hooks/useGetAllText.ts

##### 全てのデータを取得
zustandというライブラリで状態管理をしています。
状態管理にはローカルステートとグローバルステートがあります。
:::details ローカルステート
コンポーネントの中だけ使うステートを管理
React HooksのuseStateやuseReducerなど
:::
:::details グローバルステート
複数のコンポーネントで共有されるデータのステートを管理
React Hooks：useContext
外部ライブラリ：Redux、Recoilなど
:::
Getするテキストは色々使い回すのでグローバルステートで管理します。

app/hooks/useGetAllText.ts
```js
import { create } from "zustand";
import axios from "axios";

const useGetAllText = create((set) => ({
  data: [],
  loading: false,
  hasErrors: false,
  fetch: async () => {
    set(() => ({ loading: true }));
    try {
      const response = await axios.get(
        "/api/analysis"
      );
      set((state: any) => ({
        data: (state.data = response.data.getAllText),
        loading: false
      }));
    } catch (err) {
      set(() => ({ hasErrors: true, loading: false }));
    }
  },
}));

export default useGetAllText;
```
　##### コードの解説
 ```js
data: [], //テキストデータを格納するための配列を初期化
loading: false, //データの取得中かどうかを表すための真偽値を初期化
hasErrors: false, //データの取得にエラーが発生したかどうかを表すための真偽値を初期化
fetch: async () => {...}, //データの取得を行うための非同期関数を定義
set(() => ({ loading: true })); //loadingの値をtrueに変更することで、データの取得を開始

set((state: any) => ({ data: (state.data = response.data.getAllText), loading: false })); //レスポンスからテキストデータを取り出してdataに代入し、loadingの値をfalseに変更することで、データの取得が完了したことを表。stateは現在の状態オブジェクトを表す
set(() => ({ hasErrors: true, loading: false })); //hasErrorsの値をtrueに変更し、loadingの値をfalseに変更することで、データの取得にエラーが発生したことを表す
```

#### Postボタンを作成
app/components/PostButton/index.tsx
```js
import { MdPlaylistAdd } from "react-icons/md";
import axios from "axios";
import { toast } from "react-hot-toast";
import useGetAllText from "@/app/hooks/useGetAllText";

export const CreateNaisei = () => {
  const { fetch }: any = useGetAllText()
  const defaultValue = '{"root":{"children":[{"children":[{"detail":0,"format":0,"mode":"normal","style":"","text":"example.","type":"text","version":1}],"direction":"ltr","format":"","indent":0,"type":"paragraph","version":1}],"direction":"ltr","format":"","indent":0,"type":"root","version":1}}'

  const onCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    const apiUrl = "/api/naisei";
    const createData = {
      // リクエストボディに送信するデータ
      text: defaultValue,
    };
    await axios.post(apiUrl, createData)
      .then(response => {
        toast.success('Created Naisei!!')
        fetch()
        console.log("/editorでデータをフェッチ");
        return response
      })
      .catch(error => {
        console.error('Error fetching data:', error);
      });
  }
  return (

    <>
      <div className="max-w-2xl mx-auto text-end focus:outline-none">
        <button onClick={onCreate} className="border-none mr-8 cursor-pointer rounded-full hover:text-blue-600 bg-white">
          <MdPlaylistAdd size={48} color="" />
        </button>
      </div>
    </>
  )
}

```

#### コードを解説
onCreateで作成ボタンを押しすと新しいデータが作成されます。(Prismaを通してSUpabaseに保存されます）
表示画面には新しいPostのデータが反映されてないのでデータを再度フェッチします。
```js
const { fetch }: any = useGetAllText() //全てのデータを取得
 const defaultValue = '{...}' // デフォルトのデータ
 await axios.post(apiUrl, createData) //このようにしてapiしクエストを送ることができます
```

### データフェッチ
ユーザーがサイトページに訪れた時にデータをフェッチします。
データフェッチは共通コンポーネントなのでlayout.tsxで行います。

まずは、データフェッチをするコンポーネントを作ります。
app/components/DataFetch/index.tsx
```js

"use client"


import useGetAllText from "@/app/hooks/useGetAllText";
import { useEffect } from "react";

export const DataFetch = () => {
  const { fetch }: any = useGetAllText()

  useEffect(() => {
    fetch()
    console.log("/editorでデータをフェッチ");
  }, [fetch])
  return (
    <>
    </>
  )
}
```

#### サイトに追加します。
app/(site)/layout.tsx
```js
import "./styles.css"
import NavBar from "../components/Navbar/site-navbar"
import { DataFetch } from "../components/DataFetch"

const SiteLayout = ({
  children,
}: {
  children: React.ReactNode
}) => {

  return (
    <div>
      <NavBar />
      <DataFetch />
      {children}
    </div>
  )
}

export default SiteLayout
```

ログインした際にデータを取得できるようになりました。


<br />
<br />

### テキストidを管理するカスタムフック
テキストエディタには1つのPostを表示させたいのでidをグローバルステートで管理します。
app/hooks/useGetTextById.ts
```js
import { create } from "zustand";

interface TextStore {
  analysisId: string[];
  selectedId: string | null;
  setAnalysisId: (naiseiId: any[]) => void;
  setSelectedId: (naiseiId: any) => void;
};

export const useGetTextById = create<TextStore>((set) => ({
  analysisId: [""],
  selectedId: null,
  setAnalysisId: (analysisId) => set({ analysisId }),
  setSelectedId: (analysisId) => set({ selectedId: analysisId }),
}));
```

### 表示を切り替えるカスタムフック
テキストエディタに入力されたデータを切り替えるためのグローバルステートです。
app/hooks/useRefresh.ts
```js
import { create } from 'zustand';

type RefreshStore = {
  refresh: boolean;
  toggleRefresh: () => void;
};

const useRefresh = create<RefreshStore>((set) => ({
  refresh: false,
  toggleRefresh: () => set((state) => ({ refresh: !state.refresh })),
}));

export default useRefresh;
```

### ノートページの表示ロジック
app/components/Note/index.tsx
```js
"use client"

import { useEffect, useState } from "react";
import useRefresh from "@/app/hooks/useRefresh";
import useGetAllText from "@/app/hooks/useGetAllText";
import { useGetTextById } from "@/app/hooks/useGetTextById";

export const Note = () => {
  const [text, setText] = useState([])
  const { toggleRefresh } = useRefresh()
  const { data, loading }: any = useGetAllText()

  useEffect(() => {
    const resText = data.map((item: any) => item.text)
    const newArray = resText.map((item: any) => {
      const parsedItem = JSON.parse(item); // JSON文字列をJavaScriptオブジェクトに変換
      return parsedItem.root.children[0].children[0].text; // textの値を抽出
    });

    async function processData() {
      const replacedData: any = [];
      for (let i = 0; i < data.length; i++) {
        const item = { ...data[i] };
        try {
          const textObj = JSON.parse(item.text);
          if (textObj.root && textObj.root.children && textObj.root.children[0] && textObj.root.children[0].children) {
            const textValue = textObj.root.children[0].children[0].text;
            if (textValue === newArray[i]) {
              item.text = newArray[i];
            }
          }
        } catch (error) {
          console.error("Error parsing JSON:", error);
        }
        replacedData.push(item);
      }
      const newCreatedAt = replacedData.map((item: any) => {
        return {
          id: item.id,
          text: item.text,
          created_at: item.created_at.split('T')[0] // 日付部分だけを取得
        };
      });
      newCreatedAt.sort((a: any, b: any) => b.id - a.id); //日付を降順にならべ替え
      setText(newCreatedAt)

    }
    processData();
  }, [data, setText])

  const handleItemClick = (textId: number) => {
    useGetTextById.getState().setSelectedId(textId);
    toggleRefresh();
    let timeoutId = setTimeout(() => {
      // Editorのstateを更新
      toggleRefresh();
    }, 100)
    return () => {
      clearTimeout(timeoutId)
    }
  };

  return (
    <div className="flex justify-center mx-4">
      <div className="max-w-2xl">
        {!loading
          ?
          <>
            {text.map((item: any) => (
              <div
                key={item.id}
                onClick={() => handleItemClick(item.id)}
                className="my-2 rounded-md cursor-pointer px-2"
              >
                <div className="text-start text-3xl break-words whitespace-pre-wrap">{item.text}</div>
                <div className="text-slate-400 text-end">{item.created_at}</div>
              </div>
            )
            )}
            {text.length <= 0 && <div className="text-lg">Make a post now!</div>}
          </>
          :
          <div>loading.....</div>
        }
      </div>
    </div>
  )
}
```

#### コードを解説
useEffectの中ではデータの整形をしています。
:::details 具体的にどんな整形をしてるか
テキスト
整形前:'{"root":{"children":[{"children":[{"detail":0,"format":0,"mode":"normal","style":"","text":"example.","type":"text","version":1}],"direction":"ltr","format":"","indent":0,"type":"paragraph","version":1}],"direction":"ltr","format":"","indent":0,"type":"root","version":1}}'
整形後: '**example.**'

作成日
整形前: 2023-09-30T01:23:45
整形後: **2023-09-30**
:::

#### textの一番初めの行のテキストだけを取得
```js
const resText = data.map((item: any) => item.text)
    const newArray = resText.map((item: any) => {
      const parsedItem = JSON.parse(item); // JSON文字列をJavaScriptオブジェクトに変換
      return parsedItem.root.children[0].children[0].text; // textの値を抽出
    });
```

#### processData()は取得したテキストデータのtextの一番初めの行のテキストとJSON形式のテキストが一致するか検証する
```js
async function processData() {
      const replacedData: any = [];
      for (let i = 0; i < data.length; i++) {
        const item = { ...data[i] };
        try {
          const textObj = JSON.parse(item.text);
          if (textObj.root && textObj.root.children && textObj.root.children[0] && textObj.root.children[0].children) {
            const textValue = textObj.root.children[0].children[0].text;
            if (textValue === newArray[i]) {
              item.text = newArray[i];
            }
          }
        } catch (error) {
          console.error("Error parsing JSON:", error);
        }
        replacedData.push(item);
      }
      const newCreatedAt = replacedData.map((item: any) => {
        return {
          id: item.id,
          text: item.text,
          created_at: item.created_at.split('T')[0] // 日付部分だけを取得
        };
      });
      newCreatedAt.sort((a: any, b: any) => b.id - a.id); //日付を降順にならべ替え
      setText(newCreatedAt)
    }
```

#### 実際に画面の表示
```js
//テキストデータがnullの場合に表示
 {text.length <= 0 && <div className="text-lg">Make a post now!</div>}
 
 // apiの処理中はloadingを表示
  {!loading
          ?
	  //...
	  :
	  <div>loading.....</div>
        }
```


### テキストエディタが画面に表示しているステートを切り替える
トグルボタンを設置してエディタの表示・非表示を作る
:::message
エディタをトグルさせるだけではステートは更新されません。
useRefreshをうまく使いステートを更新させます
```js
{!refresh ?
              <>
                <Editor />
              </>
              :
              <div></div>
            }
```
:::


app/components/NoteItem/index.tsx
```js
"use client"

import useRefresh from "@/app/hooks/useRefresh";
import { useToggleEditor } from "@/app/hooks/useToggleEditor";
import { MdKeyboardBackspace } from "react-icons/md";


import { Editor } from "../Editor/text-editor";
import { PostButton } from "../PostButton";
import { Note } from "../Note";

export const NoteItem = () => {
  const { refresh } = useRefresh();
  const { isOpen, onClose, onOpen } = useToggleEditor()
  return (
    <>
      {
        isOpen ?
          <div className="max-w-3xl mx-auto">
            < div className="flex justify-start ml-4" >
              <button
                className="border-none cursor-pointer bg-white hover:text-blue-400"
                onClick={() => onClose()}
              >
                <MdKeyboardBackspace size={24} />
              </button>
            </div >
            {!refresh ?
              <>
                <Editor />
              </>
              :
              <div></div>
            }

          </div >
          :
          <>
            <PostButton />
            <div onClick={() => onOpen()}>
              <Note />
            </div>
          </>
      }

    </>
  )
}
```

### ページに追加
NoteItemをノートページに追加します。
```js
import { NoteItem } from "@/app/components/NoteItem/intex"

const NotePage = () => {

  return (
    <div>
      <NoteItem />
    </div>
  )
}

export default NotePage
```

### 動作確認
右上の+ボタンを押すと、ローディングが走り新しいPostをフェッチします。
トグルボタンでエディタの表示を切り替えることができていると思います。
![](https://storage.googleapis.com/zenn-user-upload/273086b2bcf0-20230929.png)

<br />
<br />

##　エディタにテキストを表示させていきます。
app/components/editor/text-editor.tsx にコードを追加していきます

app/components/Editor/text-editor.tsx
```js
'use client';
import { useEffect, useState } from "react";
import { useGetTextById } from "@/app/hooks/useGetTextById";
import useGetAllText from "@/app/hooks/useGetAllText";

export function Editor() {
    //追加
    const [text, setText] = useState('')
    const [emotion, setEmotion] = useState('')
    const selectedId = useGetTextById((state) => state.selectedId)
    const { data, fetch }: any = useGetAllText()

   //追加
    useEffect(() => {
        setText("")
        setEmotion('')
        if (selectedId !== null) {
            // data配列から選択されたIDに一致する要素を探す
            const selectedData = data.find((item: any) => item.id === selectedId);
            if (selectedData) {
                setText(selectedData.text);
                setEmotion(selectedData.emotion)

            } else {
                setText(""); // データが見つからない場合は空に設定
            }
        } else {
            setText(""); // selectedNaiseiIdがnullの場合も空に設定
        }
    }, [selectedId, data])


    const editorConfig = {
	editorState: text //追加
    };

if (!text) return <></> //追加
    return (
    {...}
        );
}

```

#### コードの解説
useEffect内でデータをmapし、useStateでステートを管理します。
```js
// stateを初期化します。初期化しないと前回のステートが残り画面表示が変わりません。
useEffect(() => {
        setText("")
        setEmotion('')
    }, [selectedId, data])
```

データがある時に処理を実行。データがない場合は空を返すようにします。
```js
if (selectedId !== null) {
            // data配列から選択されたIDに一致する要素を探す
            const selectedData = data.find((item: any) => item.id === selectedId);
            if (selectedData) {
                setText(selectedData.text);
                setEmotion(selectedData.emotion)

            } else {
                setText(""); // データが見つからない場合は空に設定
            }
        } else {
            setText(""); // selectedNaiseiIdがnullの場合も空に設定
        }
```

Lexicalのエディタにテキストを渡します。
テキストがnullの場合には何も表示させません。->このコード書かないとundifindとなり Json.paese エラーになります。
```js
 const editorConfig = {
	editorState: text //追加
    };

if (!text) return <></> //追加
```

これでエディタにデータが入るようになりました。
![](https://storage.googleapis.com/zenn-user-upload/607a4e60e5c8-20230929.png)

<br />
<br />

## APIを叩いてデータの更新と削除のボタンを作ります。
今回は、text-editor.tsxにボタンを直接書いていきます。
## データの更新
app/components/Editor/text-editor.tsx
```js
//追加
import axios from "axios";
import { useGetTextById } from "@/app/hooks/useGetTextById";
import useGetAllText from "@/app/hooks/useGetAllText";
import { useToggleEditor } from "@/app/hooks/useToggleEditor";


export function Editor() {
//追加
  const selectedId = useGetTextById((state) => state.selectedId)
  const { data, fetch }: any = useGetAllText()
  const { onClose } = useToggleEditor()

useEffect({...})
//追加
const handleUpdate = async (e: SyntheticEvent) => {
        e.preventDefault();
        onClose()
        setText("")
        const apiUrl = `/api/analysis/${selectedId}`;
        const updatedData = {
            // リクエストボディに送信するデータ
            text: text,
        };
        axios.put(apiUrl, updatedData)
            .then(response => {
                toast.success('Updated!!!!')
                fetch()
                return response
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
    }
return(
{/* ... */}
    <div className="flex justify-end">
    {/* 追加 */}
	<button className='mx-4 mb-2 mt-2 text-md cursor-pointer rounded-lg border-none px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white' onClick={handleUpdate}>Update</button>
	<GenarateButton textData={textData} />
    </div>
{/* ... */}
)
}
```

　#### コードの解説
 ボタンを押すとhandleUpdate関数が実行されます。
 アップデート後は一覧画面に戻りたいのでエディタを閉じます。
 apiを呼び出し、テキストの更新をします。
 ```js
 onClose()　//開いているエディタを閉じる
 
 //更新するテキスト(useStateの値)をaxiosを使い、apiを呼び出します。
  const updatedData = {
            // リクエストボディに送信するデータ
            text: text,
        };
        axios.put(apiUrl, updatedData)
            .then(response => {
                toast.success('Updated!!!!')
                fetch()
                return response
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
 ```

これで以下のように更新したデータが表示されればOKです。
![](https://storage.googleapis.com/zenn-user-upload/c75d92541b2a-20230929.png)
![](https://storage.googleapis.com/zenn-user-upload/7ecd0f3ddff0-20230929.png)

## データの削除
axios.deleteとすることでデータの削除ができます。
app/components/Editor/text-editor.tsx
```js
export function Editor() {
useEffect({...})

//追加
const handleDelete = async (e: SyntheticEvent) => {
        e.preventDefault();
        onClose()
        const apiUrl = `/api/analysis/${selectedId}`;
        axios.delete(apiUrl)
            .then(response => {
                fetch()
                return
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
    }
return(
{/* ... */}
    <div className="flex justify-end">
    {/* 追加 */}
<button className='mx-4 mb-2 mt-2 text-md cursor-pointer rounded-lg border-none px-4 py-2 bg-red-600 hover:bg-red-700 text-white' onClick={handleDelete}>Delete</button>
	<GenarateButton textData={textData} />
    </div>
{/* ... */}
)
}
```

先ほど更新したデータを削除します。
![](https://storage.googleapis.com/zenn-user-upload/d7d1af9beee0-20230929.png)

これでエディタ機能の作成は終了です。

<br />
<br />

## Emotionを更新
感情分析はGenarateButtonでしていますので、これにAPIのPUTメソッドを追加していきます。
app/components/GenarateButton/index.tsx
```js
"use client"

//追加
import axios from "axios";
import { useGetTextById } from "@/app/hooks/useGetTextById";


export function GenarateButton({
  textData,
}: {
  textData: string
}) {
//追加
  const selectedId = useGetTextById((state) => state.selectedId)

  const handleSubmit = async (e: { preventDefault: () => void }) => {
  ...
    }) : [];


//追加
    const apiUrl = `/api/openai/${selectedId}`;
    const updatedData = {
      emotion: filterData,
    };

    axios.put(apiUrl, updatedData)
      .then(response => {
        toast.success('Generated!!!!')
        // fetchIsNaisei()
        return response
      })
      .catch(error => {
        console.error('Error fetching data:', error);
      });
  };

  return (
    <>
      <button
        onClick={handleSubmit}
        className="mx-4 mb-2 mt-2 text-md cursor-pointer rounded-lg border-none px-4 py-2 bg-lime-600 hover:bg-lime-700 text-white"
      >
        Generate
      </button>
      {/* 削除 */}
{/* <div className="text-2xl">{generateData}</div> */}
    </ >

  )
}
```

これでemotionの更新ができるようになりました。データが保存されているか確認します。
![](https://storage.googleapis.com/zenn-user-upload/c020c2f63766-20230929.png)
これをGenerateします。
![](https://storage.googleapis.com/zenn-user-upload/da53b0ea90eb-20230929.png)
Supabaseのemotionカラムにデータが入っています。

<br />
<br />
